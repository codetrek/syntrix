# Unified Server Module: Detailed Design

**Date:** January 3, 2026
**Status:** Draft

## 1. Introduction

This document outlines the detailed design and implementation specifications for the `internal/server` module. It follows the architectural principles laid out in [01.architecture.md](01.architecture.md), specifically the **Centralized Network Layer** pattern.

## 2. Public API Design

The module exposes a minimal surface area to ensure ease of use and encapsulation.

### 2.1 Configuration (`Config`)

The configuration struct is designed to be embedded in the global application configuration.

```go
package server

import "time"

type Config struct {
	// HTTP Configuration
	HTTPPort         int           `yaml:"http_port"`
	HTTPReadTimeout  time.Duration `yaml:"http_read_timeout"`
	HTTPWriteTimeout time.Duration `yaml:"http_write_timeout"`
	HTTPIdleTimeout  time.Duration `yaml:"http_idle_timeout"`
	EnableCORS       bool          `yaml:"enable_cors"`

	// gRPC Configuration
	GRPCPort          int  `yaml:"grpc_port"`
	GRPCMaxConcurrent uint `yaml:"grpc_max_concurrent"`
	EnableReflection  bool `yaml:"enable_reflection"`

	// Lifecycle Configuration
	ShutdownTimeout time.Duration `yaml:"shutdown_timeout"`
}

// DefaultConfig returns safe defaults for development.
func DefaultConfig() Config {
	return Config{
		HTTPPort:         8080,
		HTTPReadTimeout:  10 * time.Second,
		HTTPWriteTimeout: 10 * time.Second,
		HTTPIdleTimeout:  60 * time.Second,
		GRPCPort:         9090,
		ShutdownTimeout:  10 * time.Second,
	}
}
```

### 2.2 Service Interface (`Service`)

The interface abstracts the underlying server implementations.

```go
package server

import (
	"context"
	"net/http"

	"google.golang.org/grpc"
)

type Service interface {
	// Start initializes and starts the HTTP and gRPC listeners.
	// It blocks until a fatal error occurs or the context is canceled.
	Start(ctx context.Context) error

	// Stop initiates a graceful shutdown of all servers.
	// It waits for active connections to drain or for the context to expire.
	Stop(ctx context.Context) error

	// RegisterHTTPHandler registers a handler for a specific pattern.
	// This must be called BEFORE Start().
	RegisterHTTPHandler(pattern string, handler http.Handler)

	// RegisterGRPCService registers a gRPC service implementation.
	// This must be called BEFORE Start().
	RegisterGRPCService(desc *grpc.ServiceDesc, impl interface{})
}
```

## 3. Internal Implementation

The implementation is hidden behind the `serverImpl` struct.

### 3.1 Struct Definition

```go
type serverImpl struct {
	cfg    Config
	logger *slog.Logger

	// HTTP State
	httpMux    *http.ServeMux
	httpServer *http.Server

	// gRPC State
	grpcServer *grpc.Server

	// Lifecycle State
	mu       sync.Mutex
	started  bool
	shutdown bool
}
```

### 3.2 Initialization Logic (`New`)

The `New` function prepares the servers but does not start listening.

1.  Validate configuration.
2.  Initialize `http.ServeMux`.
3.  Initialize `grpc.Server` with default interceptors (Recovery, Logging).
4.  Return `&serverImpl{...}`.

### 3.3 Startup Logic (`Start`)

The `Start` method is the critical section for concurrency.

```go
func (s *serverImpl) Start(ctx context.Context) error {
	s.mu.Lock()
	if s.started {
		s.mu.Unlock()
		return errors.New("server already started")
	}
	s.started = true
	s.mu.Unlock()

	// 1. Configure HTTP Server (Apply Middleware, Timeouts)
	s.httpServer = &http.Server{
		Addr:         fmt.Sprintf(":%d", s.cfg.HTTPPort),
		Handler:      s.wrapMiddleware(s.httpMux),
		ReadTimeout:  s.cfg.HTTPReadTimeout,
		WriteTimeout: s.cfg.HTTPWriteTimeout,
		// ...
	}

	// 2. Create Error Channel
	errChan := make(chan error, 2)

	// 3. Start HTTP Listener
	go func() {
		s.logger.Info("Starting HTTP server", "port", s.cfg.HTTPPort)
		if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			errChan <- fmt.Errorf("http server error: %w", err)
		}
	}()

	// 4. Start gRPC Listener
	go func() {
		lis, err := net.Listen("tcp", fmt.Sprintf(":%d", s.cfg.GRPCPort))
		if err != nil {
			errChan <- fmt.Errorf("grpc listen error: %w", err)
			return
		}
		s.logger.Info("Starting gRPC server", "port", s.cfg.GRPCPort)
		if err := s.grpcServer.Serve(lis); err != nil {
			errChan <- fmt.Errorf("grpc server error: %w", err)
		}
	}()

	// 5. Wait for Error or Context Cancellation
	select {
	case err := <-errChan:
		return err
	case <-ctx.Done():
		return nil // Normal shutdown signal
	}
}
```

### 3.4 Shutdown Logic (`Stop`)

```go
func (s *serverImpl) Stop(ctx context.Context) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	var wg sync.WaitGroup
	errChan := make(chan error, 2)

	// Shutdown HTTP
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := s.httpServer.Shutdown(ctx); err != nil {
			errChan <- fmt.Errorf("http shutdown error: %w", err)
		}
	}()

	// Shutdown gRPC
	wg.Add(1)
	go func() {
		defer wg.Done()
		s.grpcServer.GracefulStop()
		// Note: grpc.GracefulStop doesn't take a context,
		// so we might need a separate goroutine to force Stop() if ctx expires.
	}()

	wg.Wait()
	close(errChan)

	// Collect errors
	var errs []error
	for err := range errChan {
		errs = append(errs, err)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}
```

## 4. Middleware & Interceptors

### 4.1 HTTP Middleware Chain

The middleware chain is implemented using a simple function wrapping pattern.

```go
// Middleware defines a function that wraps an http.Handler.
type Middleware func(http.Handler) http.Handler

// Chain applies middlewares in reverse order.
func Chain(h http.Handler, mws ...Middleware) http.Handler {
    for i := len(mws) - 1; i >= 0; i-- {
        h = mws[i](h)
    }
    return h
}

// wrapMiddleware applies the standard middleware stack.
func (s *serverImpl) wrapMiddleware(h http.Handler) http.Handler {
    return Chain(h,
        s.recoveryMiddleware,
        s.requestIDMiddleware,
        s.loggingMiddleware,
        s.corsMiddleware, // Conditional based on cfg.EnableCORS
    )
}
```

#### 4.1.1 Recovery Middleware
Recovers from panics, logs the stack trace, and returns HTTP 500.

#### 4.1.2 Request ID Middleware
Checks for `X-Request-ID` header. If missing, generates a UUID. Adds it to the request context and response headers.

#### 4.1.3 Logging Middleware
Logs the request completion using `slog`.
- **Level**: Info (or Error if status >= 500)
- **Fields**: `method`, `path`, `status`, `duration`, `ip`, `request_id`.

#### 4.1.4 CORS Middleware
Handles OPTIONS requests and sets Access-Control headers based on configuration.

### 4.2 gRPC Interceptors

We use `grpc.ChainUnaryInterceptor` and `grpc.ChainStreamInterceptor` to apply interceptors.

```go
func (s *serverImpl) unaryInterceptors() grpc.ServerOption {
    interceptors := []grpc.UnaryServerInterceptor{
        s.recoveryUnaryInterceptor(),
        s.loggingUnaryInterceptor(),
    }
    return grpc.ChainUnaryInterceptor(interceptors...)
}

func (s *serverImpl) streamInterceptors() grpc.ServerOption {
    interceptors := []grpc.StreamServerInterceptor{
        s.recoveryStreamInterceptor(),
        s.loggingStreamInterceptor(),
    }
    return grpc.ChainStreamInterceptor(interceptors...)
}
```

#### 4.2.1 Recovery Interceptor
Catches panics in gRPC handlers and returns `codes.Internal` error.

#### 4.2.2 Logging Interceptor
Logs gRPC calls.
- **Fields**: `service`, `method`, `code`, `duration`, `error`.


## 5. Usage Example

```go
// In internal/services/manager.go

func (m *Manager) Init() {
    // 1. Create Server Service
    srv := server.New(m.cfg.Server)

    // 2. Initialize Modules
    apiHandler := api.NewHandler(...)
    pullerSvc := puller.NewService(...)

    // 3. Register
    srv.RegisterHTTPHandler("/api", apiHandler)
    srv.RegisterGRPCService(&pb.Puller_ServiceDesc, pullerSvc)

    m.server = srv
}

func (m *Manager) Start(ctx context.Context) {
    // 4. Start Server (Blocking)
    go func() {
        if err := m.server.Start(ctx); err != nil {
            log.Fatal(err)
        }
    }()
}
```
